### 方法二：贪心 + 二分查找

确实，方法二：**贪心 + 二分查找**的解决方案，虽然在效率上较高，但理解起来可能不如动态规划直观。这个方法利用了一种优化的策略，旨在构建一个尽可能长的递增子序列。这里详细解释一下这个方法是如何工作的，以帮助您更好地理解。
```cpp
int lengthOfLIS(vector<int>& nums)
{
    vector<int> tails;
    for (int num : nums) {
        auto it = lower_bound(tails.begin(), tails.end(), num);
        if (it == tails.end())
            tails.push_back(num);
        else
            *it = num;
    }
    return tails.size();
}
```

**核心思想**：
该方法的核心在于使用一个数组 `tails`，其中每个元素 `tails[i]` 表示所有长度为 `i+1` 的递增子序列中最小的末尾元素。我们通过维护这样一个数组，可以用来判断新遇到的数字应该被放在哪个位置来可能延长已有的子序列或者起始一个新的子序列。

**步骤解释**：

1. **初始化**：创建一个空的 `tails` 数组。
  
2. **遍历数组**：对于输入数组 `nums` 中的每一个数字 `num`，我们用二分查找在 `tails` 中找到第一个大于等于 `num` 的元素的位置。这是因为如果 `num` 能替换一个更大的数，这将有助于后续可能形成更长的递增子序列。

3. **更新 `tails`**：
    - 如果找到的位置等于 `tails` 的当前长度，表示 `num` 大于 `tails` 中所有元素，我们将 `num` 添加到 `tails` 的末尾。
    - 如果找到了一个位置，那么更新那个位置的值为 `num`，因为更小的 `num` 可以增加后续形成更长递增子序列的可能性。

4. **结果**：遍历结束后，`tails` 的长度就是最长递增子序列的长度。

### 为什么这个方法有效？

- **替换策略**：通过替换 `tails` 中某个元素，我们不是真的在改变已有的子序列，而是在维护一个潜在的最佳状态，即对于每种长度的最长递增子序列可能的最小末尾元素。
- **保持可能性**：这种方法的关键在于，虽然 `tails` 数组中的具体值并不一定是真正的子序列，但数组的长度反映了可以形成的最长递增子序列的长度。

通过上面的解释，希望能帮助您更好地理解这个方法的运作原理和它为什么能够高效解决问题。这种方法特别适合处理大数据集，因为它大大减少了必要的计算步骤。
