#pragma once
#include <string>
using namespace std;

/*
* 266. 回文排列
给你一个字符串 s ，如果该字符串的某个排列是 回文串 ，则返回 true ；否则，返回 false 。（s 仅由小写英文字母组成）

思路分析：位操作
回文串的特点是，所有的字母必须成对出现，至多只能有一个字符落单；
s 仅由小写英文字母组成；隐含的意思是，可以把每个字符相对于'a'字符的offset，映射成一个整数，介于[0, 25]之间；
然后再把这个整数，映射成一个int类型v的比特位置索引；
把每个字母对应的比特位置进行异或操作；
那么偶数次出现的字母会进行偶数次的异或操作，结果为0；奇数次出现的字母会进行奇数次的异或操作，结果为0；
最后统计v的二进制表示中，`1`比特的个数应该为0，或者至多有一个`1`比特；
如果有一个`1`比特，那么它必然也是lowbit；使用干掉lowbit的技巧：(v & (v - 1))
(v & (v - 1)) == 0 等价于：v中有0个，或者至多一个`1`比特！
*/

class Solution_0226 {
public:
    bool canPermutePalindrome(string s)
    {
        int v = 0;
        for (char c : s) {
            int i = c - 'a'; // 小写字母映射成整数，介于[0, 25]之间；用这个整数来标识比特位；
            v ^= (1 << i); // 整数v中对应位置的比特位与`1`进行异或操作；偶数次的异或操作结果为0；奇数次的异或操作结果为1；
        }
        return (v & (v - 1)) == 0; // 整数v的二进制表示中，至多只能有一个`1`比特。
    }
};