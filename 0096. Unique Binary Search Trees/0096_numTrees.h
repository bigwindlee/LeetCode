#pragma once
#include <vector>
using namespace std;

/*
二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的二叉树： 
若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 
若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 
它的左、右子树也分别为二叉排序树。
*/

class Solution_0096 {
public:
    int numTrees(int n)
    {
        vector<int> dp(n + 1); // 节点个数从0到n，总共n+1中情况。dp[i]表示 i 个节点能组成的BST的总个数。

        // 给定根节点，则其BST的总数为：左子树的可能总数 * 右子树的可能总数
        // 单个节点能组成 1 个BST，单个节点的左右子树都是空树，那么根据定义的统一性，空树的可能总数也是 1.
        dp[0] = 1;
        dp[1] = 1; // 左右都是空树，dp[1] = dp[0] * dp[0]

        for (int i = 2; i <= n; ++i) { // 序列中有i个节点
            for (int j = 1; j <= i; ++j) { // i 个节点中以 j 为根节点，左子树节点个数：j-1；右子树节点个数 i-j
                // 动规核心：状态转移方程
                dp[i] += dp[j - 1] * dp[i - j]; // 随着顶点位置j的游走，对左右子树可能总数的乘积进行累加。
            }
        }
        return dp[n];
    }
};