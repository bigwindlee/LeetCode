#pragma once
#include <string>
#include <vector>
using namespace std;

/*
555. 分割连接字符串
给定一个字符串列表 strs，你可以将这些字符串连接成一个循环字符串，对于每个字符串，你可以选择是否翻转它。在所有可能的循环字符串中，你需要分割循环字符串（这将使循环字符串变成一个常规的字符串），然后找到字典序最大的字符串。
具体来说，要找到字典序最大的字符串，你需要经历两个阶段：
  1. 将所有字符串连接成一个循环字符串，你可以选择是否翻转某些字符串，并按照给定的顺序连接它们。
  2. 在循环字符串的某个位置分割它，这将使循环字符串从分割点变成一个常规的字符串。
你的工作是在所有可能的常规字符串中找到字典序最大的一个。

思路分析：
  1. 选择每个字符串的最优形式：对于给定的字符串列表 strs，可以选择保留每个字符串的原始形式或其翻转形式。为了得到字典序最大的结果，首先需要比较每个字符串及其翻转形式，选择字典序较大的那个作为该字符串的最优形式。
  2. 连接字符串：将所有字符串（经过选择最优形式后）按顺序连接起来，形成一个循环字符串。这个循环字符串可以从任意位置切分，切分后形成一个新的常规字符串。
  3. 尝试所有切割位置：对于循环字符串中的每个位置，将其视作分割点。需要分别尝试每个字符串的正序和反序形式，从不同的位置切割，形成新的字符串，并比较其字典序。
  4. 维护最大字典序字符串：在所有可能的切割方式中，维护字典序最大的那个字符串，最终返回该结果。

知识点：
  1. 字符串原地翻转；
  2. 利用下标模运算循环遍历字符串内部的字符；
  3. 利用迭代器遍历/分割字符串；
*/

class Solution {
public:
    string splitLoopedString(vector<string>& strs)
    {
        string ans;
        int n = strs.size();

        // 原字符串和反转字符串，选取字典序更大的，原地修改；
        // 除了要被剪开的字符串，剩下的字符串肯定是字典序更大的更好；
        for (string& s : strs) {
            string rev = string(s.rbegin(), s.rend());
            if (rev > s) {
                s = rev;
            }
        }

        for (int i = 0; i < n; ++i) {
            string rest; // 除了被剪开的，把剩下的字符串拼接在一起
            for (int j = i + 1; j < n + i; ++j) {
                rest += strs[j % n]; // 数组下标模运算，拼接循环字符串的技巧
            }
            // i 字符串要被剪开，i 字符串本身并不确定保留大字典序效果更好，所以要都试试；
            for (string& str : vector<string> { strs[i], string(strs[i].rbegin(), strs[i].rend()) }) {
                for (auto it = str.begin(); it != str.end(); ++it) { // 尝试从每一个位置剪开，然后拼接
                    string candidate = string(it, str.end()) + rest + string(str.begin(), it);
                    ans = max(ans, candidate);
                }
            }
        }
        return ans;
    }
};