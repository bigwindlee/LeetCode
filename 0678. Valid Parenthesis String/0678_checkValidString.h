#pragma once
#include <string>
using namespace std;

/*
678. 有效的括号字符串
给你一个只包含三种字符的字符串，支持的字符类型分别是 '('、')' 和 '*'。请你检验这个字符串是否为有效字符串，如果是 有效 字符串返回 true 。

`有效`字符串符合如下规则：
  ● 任何左括号 '(' 必须有相应的右括号 ')'。
  ● 任何右括号 ')' 必须有相应的左括号 '(' 。
  ● 左括号 '(' 必须在对应的右括号之前 ')'。
  ● '*' 可以被视为单个右括号 ')' ，或单个左括号 '(' ，或一个空字符串 ""。
*/

/*
思维难点：
Q: 为什么遇到明确的右括号，没有无条件的对low减1？
A: high值的存在，保证了右括号的数量不会超出。low值的作用是，在“右括号数量不会超出”的前提下，记录未匹配左括号的数量，能否向0靠拢！
   如果low值为0的时候遇到了右括号，这意味着一定有'*'供右括号消耗，否则违背了“右括号数量不会超出”的前提！
   low值始终工作在“右括号数量不会超出”的前提下，尽可能保守的记录左括号的剩余量，使之向0靠拢。
   如果low值为0，但遇到了右括号，这意味着一定存在某种不太保守的中间状态，把一个'*'号当做左括号，与右括号进行匹配。
   所有low值如果为正，则向0靠拢；如果已经为0，就没必要减1变成负数了。
   “右括号数量不会超出” <==> “左括号数量一定够用”
*/
class Solution_0678 {
public:
    bool checkValidString(string s)
    {
        // high: 最乐观的左括号净值。将所有'*'当做左括号，在被右括号消耗后的剩余数量。
        // low: 在“左括号数量一定够用”的前提下，未匹配左括号数量，尽量向0靠拢。
        // low工作在受保护状态，任何时候第一时间向0靠拢都是正确的，不存在“过度”靠拢的情况，可认为是“贪心”算法的思想。
        // 因为low在受保护状态下降到0以后，遇到右括号，可以不用搭理它。
        int low = 0, high = 0;

        for (char c : s) {
            if (c == '(') {
                ++low;
                ++high;
            } else if (c == ')') {
                if (low > 0)
                    --low;
                if (--high < 0)
                    return false; // 如果 high为负，说明右括号太多，即使所有星号都当作左括号也不够
            } else if (c == '*') {
                if (low > 0)
                    --low;
                ++high;
            }
        }
        return low == 0; // 如果 low 为 0，说明左括号和右括号正好匹配
    }
};

/*
dfs暴搜
[超出时间限制                                         79 / 83 个通过的测试用例]
最后执行的输入：
s = "**************************************************))))))))))))))))))))))))))))))))))))))))))))))))))"

问题分析：
时间复杂度：3^n，n是星号的个数。由此可见当星号个数太多时，dfs搜索树的分支会暴涨！超出时间限制！
*/
class Solution_0678_02 {
public:
    bool checkValidString(string s)
    {
        return dfs(s, 0, 0);
    }

    // count: 左括号的净值（要减去右括号对左括号的消耗）
    bool dfs(string& s, int idx, int count)
    {
        if (count < 0) {
            return false;
        }
        if (idx == s.size()) {
            return count == 0;
        }
        if (s[idx] == '(') {
            return dfs(s, idx + 1, count + 1);
        } else if (s[idx] == ')') {
            return dfs(s, idx + 1, count - 1);
        } else {
            // 遇到'*'号，产生3个搜索方向。
            return dfs(s, idx + 1, count) || dfs(s, idx + 1, count - 1) || dfs(s, idx + 1, count + 1);
        }
    }
};