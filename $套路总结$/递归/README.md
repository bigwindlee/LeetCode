|LeetCode|要点|
|-----------------------------|-----------------------------|
|[24. 两两交换链表中的节点][github-leetcode-0024]|这是典型的用递归处理链表问题；只做前2个节点，后面的交给递归函数去做！|
|[25. K 个一组翻转链表][github-leetcode-0025]|头插法反转链表；递归；|
| 82. 删除排序链表中的重复元素 II |在递归函数体内只处理一个节点，剩下的节点交给递归函数去处理；而且要用子问题的解来表达当前节点（部分表达整体）。|
| 104. 二叉树的最大深度||
| 206. 反转链表 | 三指针解法；头插法；递归法；|
| 236. 二叉树的最近公共祖先 |DFS搜索p/q节点中的任何一个，如果左右子树都不为空，说明p/q分居当前节点的左右子树，则将当前节点上浮；否则上浮非空的子节点。|
|[258. 各位相加][github-leetcode-0258]|普通递归；或者数论--求树根；|
|LCR 024. 反转链表|同206. 反转链表|
|LCR 175. 计算二叉树的深度|同104. 二叉树的最大深度|

# 递归的适用场景与核心要点

递归是一种常见的编程方法，适用于多种问题，尤其是涉及**分治思想**、**递归结构**和**回溯**的场景。下面我将总结递归的适用场景，以及如何适用递归解决此类问题的核心要点。

## 一、递归的适用场景

1. **树形结构问题**：
   - 树的遍历、查找、节点操作等问题，例如二叉树的最近公共祖先、最大深度、节点路径查找等。
   - 树的自然结构适合递归，因为每个子树都是一个独立的递归子问题。

2. **链表问题**：
   - 链表是一种递归数据结构，递归可以方便地处理涉及节点操作的链表问题，例如删除节点、反转链表等。
   - 示例：`LeetCode 82 - 删除排序链表中的重复元素 II`。

3. **分治问题**：
   - 当问题可以分解为多个独立的子问题时，递归非常适用，例如归并排序、快速排序、二分搜索等算法。

4. **图的遍历**：
   - 图的深度优先搜索（DFS）和广度优先搜索（BFS）都可以通过递归实现。
   - 图的遍历问题包括查找路径、连通性、岛屿问题等。

5. **动态规划中的递归子问题**：
   - 许多动态规划问题本质上是递归问题的优化版本，可以用递归解决，后通过记忆化递归优化效率。
   - 示例：斐波那契数列、背包问题、最短路径问题等。

6. **组合与排列问题**：
   - 生成排列组合或解决类似问题时，递归用于逐层枚举所有可能的状态。
   - 示例：全排列、子集生成等问题。

7. **递归结构的数据**：
   - 当数据本身具有递归性质时，例如树、链表、分形结构，递归是自然的解决方式。

## 二、递归解决问题的核心要点

1. **确定递归边界条件**：
   - 每个递归函数都必须有明确的终止条件，以避免无限递归。
   - 通常是处理到基础情况时直接返回结果。
   - 在链表问题中，递归边界条件通常是到达链表末尾（`nullptr`），或只剩一个节点。

2. **分解问题为子问题**：
   - 将原问题分解为规模更小的子问题，递归处理子问题后，将结果合并。
   - 分治思想在这里非常重要，必须明确每层递归在做什么。

3. **递归的回溯过程**：
   - 在递归函数的回溯过程中，逐层合并子问题的解。每一层递归调用可能会修改数据结构或返回结果给上一层。
   - 在链表问题中，通常会递归处理剩余部分的链表，然后根据递归结果调整当前节点。

4. **处理递归后的结果**：
   - 每一层递归会返回相应的结果，你需要根据返回值来进行操作（例如重新连接链表节点，或者返回新的子树）。

5. **递归状态的传递和恢复**：
   - 在递归过程中，需要保持状态（如链表的头节点，树的当前节点等），并在递归返回时恢复状态。

## 总结

递归的适用场景多种多样，尤其是在处理具有递归性质的数据结构或可以分治的问题时，递归非常有效。要使用递归解决这类问题，核心要点是：

1. 明确递归终止条件。
2. 分解问题为子问题。
3. 递归地解决子问题并回溯合并结果。
4. 保持并传递必要的状态。


[github-leetcode-0258]: ../../0258.%20Add%20Digits/0258_addDigits.h
[github-leetcode-0024]: ../../0024.%20Swap%20Nodes%20in%20Pairs/0024_swapPairs.h
[github-leetcode-0025]: ../../0025.%20Reverse%20Nodes%20in%20k-Group/0025_reverseKGroup.h
