|LeetCode|要点|
|---------------------------------------|---------------------------------------|
|[20. 有效的括号][github-leetcode-0020]|扫描到左括号，把对应的右括号入栈，避免建立映射关系；|
|[224. 基本计算器][github-leetcode-0224]|栈：遇见运算符，入栈上一次的运算符和操作数；|
|[227. 基本计算器 II][github-leetcode-0227]|栈：遇见运算符，入栈上一次的运算符和操作数；|
|[232. 用栈实现队列][github-leetcode-0232]|把数据从`输入栈`倒入`输出栈`的条件是`输出栈`为空，这样就维持了`输出栈顶`是`队列开头`的定义。|
|[394. 字符串解码][github-leetcode-0394]|双栈分别收集字符和数字（重复次数）|
|[445. 两数相加 II][github-leetcode-0445]|双栈：栈顶数字从个位数开始，从而可以对齐。|
|[772. 基本计算器 III][github-leetcode-0772]|栈：遇见运算符，入栈上一次的运算符和操作数；|


# 双栈模式

双栈模式在算法和编程中是一个常用的技巧，尤其适用于需要处理嵌套结构、优先级顺序或两种不同类型数据的场景。通过双栈，可以将不同的处理逻辑分开，简化操作，同时提高代码的可读性和可维护性。以下是双栈模式的一般化总结。

## 双栈模式的基本思路
双栈模式通常涉及两个独立的栈，分别用来处理不同类型的数据或任务。这两个栈常常配合使用，以应对复杂的计算或解析任务。在这种模式中，每个栈分别管理一种职责（如操作符与操作数、字符串与重复次数等），通过这种分离来简化操作和维护。

## 典型使用场景
双栈模式在以下几类问题中非常常见：

### 1. **表达式求值（如“计算器”问题）**
典型问题：LeetCode 224 和 LeetCode 227
- **操作数栈**：用于保存操作数（如数字）。
- **操作符栈**：用于保存操作符（如 `+`, `-`, `*`, `/`），以及括号等。

场景：在处理复杂的算术表达式时，操作符和操作数之间的优先级关系以及括号的嵌套要求我们用不同的栈来管理数据。当遇到括号时，需要暂时保存当前的计算结果和操作符，直到遇到相应的结束括号。

### 2. **字符串解码（如括号嵌套结构）**
典型问题：LeetCode 394
- **字符串栈**：保存当前解析的子字符串。
- **次数栈**：保存每个子字符串的重复次数。

场景：解析嵌套的字符串模式如 `k[encoded_string]`，要求我们能在遇到 `]` 时回溯到相应的 `[` 并完成子字符串的重复操作。使用双栈可以分别存储每一层嵌套的字符串和其对应的重复次数，便于处理嵌套结构。

### 3. **树/图的遍历**
在某些树或图的遍历问题中，双栈也可以用来帮助处理遍历顺序或辅助状态的保存。例如：
- **前序遍历与后序遍历的关系**：前序遍历的逆序结果就是后序遍历的结果。使用两个栈，一个栈用于保存节点，另一个栈用于反向存储遍历顺序，最终生成后序遍历。

### 4. **处理带有撤销操作的系统**
双栈模式常用于实现“撤销/重做”操作：
- **操作栈（Undo Stack）**：保存历史操作。
- **撤销栈（Redo Stack）**：保存被撤销的操作，允许用户恢复（重做）这些操作。

当用户执行操作时，将操作压入 `Undo Stack`。当用户撤销操作时，将该操作从 `Undo Stack` 弹出并压入 `Redo Stack`，以便用户能进行重做。

## 双栈模式的优势
1. **逻辑清晰**：使用两个栈将不同类型的数据分离处理，逻辑更加清晰。例如，一个栈处理操作数，另一个栈处理操作符，减少了不同数据类型之间的耦合，便于管理。
2. **便于处理嵌套结构**：双栈模式非常适合处理具有层次结构或嵌套结构的问题，如括号匹配、子表达式求值、嵌套字符串解码等。
3. **优先级管理**：在处理算术表达式时，双栈模式可以方便地处理操作符的优先级，并允许使用中缀表达式的方式逐步求值。
4. **状态保存与回溯**：在遇到需要暂存某些状态、回溯上一步操作时，双栈模式非常高效。例如，计算器问题中的括号求值，以及“撤销/重做”操作的处理。

## 双栈模式的一般化模板

1. **初始化两个栈**：
   - 一个栈用于保存操作数或结果。
   - 另一个栈用于保存操作符或辅助数据（如括号、重复次数等）。

2. **遍历输入数据**：
   - 对于每一个字符或数据：
     - 如果是操作数/子串，解析并压入操作数栈。
     - 如果是操作符或特殊标记（如 `[` 或 `(`），压入操作符栈。
   
3. **遇到特殊标记**（如 `]` 或 `)`）：
   - 从操作数栈和操作符栈中弹出相应的元素，进行部分计算。
   - 将计算结果压入操作数栈，以便继续进行后续的处理。

4. **最终处理**：
   - 当遍历完所有输入后，栈中可能还会残留部分未计算的数据，继续出栈进行计算，直到得到最终结果。

## 双栈模式的示例结构

```cpp
// 双栈的一般模板
stack<int> nums;  // 数字/操作数栈
stack<char> ops;  // 符号/操作符栈

for (char c : input) {
    if (isdigit(c)) {
        // 处理数字
        nums.push(number);
    } else if (c == '(') {
        // 左括号，压入操作符栈
        ops.push(c);
    } else if (c == ')') {
        // 右括号，进行部分计算
        while (ops.top() != '(') {
            // 弹出并计算
            compute(nums, ops);
        }
        ops.pop();  // 弹出左括号
    } else {
        // 处理加减乘除等操作符
        while (!ops.empty() && precedence(ops.top()) >= precedence(c)) {
            compute(nums, ops);
        }
        ops.push(c);  // 压入当前操作符
    }
}

// 处理完所有字符后，计算剩余栈中的内容
while (!ops.empty()) {
    compute(nums, ops);
}
```

## 总结
双栈模式适用于需要分别处理两类不同数据（如操作数与操作符）的场景，特别是嵌套表达式和优先级处理。它的优势在于清晰的结构化逻辑，尤其在解析和计算涉及嵌套结构、操作符优先级的表达式时，双栈模式提供了简洁且高效的解决方案。


[github-leetcode-0020]: ../../0020.%20Valid%20Parentheses/0020_isValid.h
[github-leetcode-0232]: ../../0232.%20Implement%20Queue%20using%20Stacks/0232_MyQueue.h
[github-leetcode-0394]: ../../0394.%20Decode%20String/0394_decodeString.h
[github-leetcode-0772]: ../../0772.%20Basic%20Calculator%20III/0772_calculate.h
[github-leetcode-0227]: ../../0227.%20Basic%20Calculator%20II/0227_calculate.h
[github-leetcode-0224]: ../../0224.%20Basic%20Calculator/0224_calculate.h
[github-leetcode-0445]: ../../0445.%20Add%20Two%20Numbers%20II/0445_addTwoNumbers.h
