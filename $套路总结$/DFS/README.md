| LeetCode | 要点 |
| ----------- | ----------- |
| [2571. 将整数减少到零需要的最少操作数][github-leetcode-2571] |位运算 + DFS；搜索方向：+/- lowbit|


# 深度优先搜索算法（DFS）详述

## 1. 什么是深度优先搜索（DFS）？

**深度优先搜索**（Depth-First Search，简称 DFS）是一种用于遍历或搜索图和树形结构的算法。它从初始节点开始，沿着每一个分支不断深入到树或图的最深处，直到不能再继续为止，然后回溯并尝试其他分支，直到所有可能的路径都被探索完。

DFS 通常可以通过递归或栈来实现。

## 2. DFS 的核心思想

- **深入探索**：DFS 会沿着一条路径从起始节点不断往前搜索，直到到达叶子节点（或无后续节点），然后回溯到上一层节点。
- **回溯**：在搜索过程中，如果当前路径到达了一个无法继续前进的节点（即没有未被访问的邻接节点），算法会回溯到上一层，继续探索其他未访问的邻接节点。
- **全局视角**：DFS 会遍历所有可能的路径，并尝试从每个节点开始探索，以确保完整搜索。

DFS 的执行流程如下：
1. 选择一个未被访问的起点。
2. 从起点出发，依次访问每个可能的子节点，沿着某条路径不断深入。
3. 如果当前节点没有未访问的邻接节点，则回溯到上一个节点。
4. 重复步骤 2 和 3，直到所有节点都被访问或找到解答为止。

## 3. 适合使用 DFS 的题目类型

DFS 是一种非常通用的算法，适用于多种不同类型的问题，尤其是以下几类题目：

### 1. **图的遍历和连通性问题**
   - **无向图连通性**：确定无向图是否连通，或者找出图中连通分量。
   - **有向图中的强连通分量**：可以通过 DFS 找到有向图的强连通分量。

### 2. **路径和可达性问题**
   - **迷宫问题**：给定一个迷宫或网格，判断从起点到终点是否存在一条可通行的路径。
   - **连通路径问题**：判断两个节点之间是否存在路径，或找到从起点到终点的所有路径。

### 3. **排列、组合、子集生成问题**
   - **全排列/组合问题**：给定一组元素，生成所有可能的排列或组合。
   - **子集生成**：DFS 常用于解决子集生成问题，列出所有可能的子集。

### 4. **树形结构问题**
   - **二叉树的遍历**：DFS 是树遍历的基本方法之一，包括前序、中序和后序遍历。
   - **树的最大/最小深度**：通过 DFS，可以轻松找到树的最大深度或最小深度。

### 5. **回溯问题**
   - **N 皇后问题**：DFS 与回溯结合，可以用于解决 N 皇后问题，即在 NxN 的棋盘上放置 N 个皇后，互相之间不攻击的摆法。
   - **解数独问题**：DFS 可以用来解决数独填空问题，通过尝试所有可能的数字组合，找到符合规则的解。

### 6. **拓扑排序**
   - **有向无环图的拓扑排序**：可以通过 DFS 获取图的拓扑序列。

### 7. **连通性和路径问题中的搜索优化**
   - **深度有限搜索**：在某些情况下，需要控制 DFS 的深度，以避免陷入过深的递归。

## 4. DFS 的核心思想与特点

### **核心思想**：
DFS 的核心思想是"尽可能深地搜索"，即优先沿着某条路径探索到底，只有在当前路径走不通时，才会回溯并选择其他路径。其关键思想可以归纳为以下几点：
- **递归或栈实现**：DFS 常使用递归来实现，或者也可以通过显式使用栈的方式来实现深度优先遍历。
- **回溯处理**：DFS 的路径探索具备回溯的特点，即遇到死胡同时，回退到上一个节点继续探索其他未访问的邻接节点。
- **状态标记**：为了避免重复访问节点，DFS 通常会记录访问过的节点（如通过一个布尔数组 `visited`）。

### **DFS 的特点**：
- **深度优先**：优先探索更深的路径。
- **回溯处理**：当到达没有可选路径的节点时，回退到上一个节点继续探索其他路径。
- **适合树和图的遍历**：DFS 是树和图遍历中的经典算法，能够访问所有的节点，并进行状态更新。
- **栈结构**：DFS 在本质上可以看作是一个基于栈的算法，递归调用隐式使用了系统栈，非递归实现时可以显式使用栈。

## 5. DFS 与 BFS 的对比

- **DFS（深度优先搜索）**：
  - 先深入，再回溯。
  - 更适合找到 **某一条路径**，或解决 **排列组合、回溯类** 的问题。
  - 实现上可以使用递归或栈。
  - 对于较深的搜索树，DFS 可能陷入深度递归，消耗较多空间。

- **BFS（广度优先搜索）**：
  - 先广度，再深度。
  - 更适合找到 **最短路径**，或者解决 **层级遍历** 类的问题。
  - 通常使用队列来实现。
  - BFS 通常可以保证找到的路径是最短的。

## 6. DFS 的优缺点

### **优点**：
- **实现简单**：DFS 的递归实现方式相对直观。
- **适合深层搜索**：在搜索树非常深的情况下，DFS 能更快找到解答。
- **适合回溯问题**：DFS 非常适合用于解决回溯类问题，例如全排列、组合等。

### **缺点**：
- **容易陷入死胡同**：在某些问题中，DFS 可能会过早地深入某条错误路径，从而导致不必要的时间浪费。
- **空间消耗较大**：递归深度过大时，可能会导致栈溢出。
- **无法保证最优解**：DFS 并不能保证找到的是最短路径或最优解。

---

DFS 是图和树遍历中的经典算法，适用于许多需要深层探索和回溯的场景。它是解决组合、排列、子集生成、路径探索等问题的基础算法。


[github-leetcode-2571]: ../../2571.%20Minimum%20Operations%20to%20Reduce/2571_minOperations.h