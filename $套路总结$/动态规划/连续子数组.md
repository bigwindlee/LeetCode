# 动态规划解决“连续子数组”问题的核心要点

在解决**连续子数组**相关问题时，有几个核心要点和通用的思路可以帮助我们有效地解题。以下是这类问题的核心要点总结：

## 1. 维护状态的动态更新
   - **关键点**：当我们遍历数组时，需要维护一些状态（如当前的最大值、最小值、前缀和等），并根据当前元素和之前的状态动态更新结果。
   - **举例**：在最大子数组和（LeetCode 53）问题中，我们维护一个 `currSum`，表示以当前元素结尾的最大子数组和。对于每个元素，计算 `currSum = max(nums[i], currSum + nums[i])` 来决定是继续累加还是重新开始一个新的子数组。

## 2. 考虑正负数的影响
   - **关键点**：在处理与乘积相关的问题（如 LeetCode 152 乘积最大子数组）时，正负数的存在会影响计算结果，因此我们需要同时维护最小乘积和最大乘积。
   - **举例**：如果遇到负数，乘以一个较大的正数会变成负数，反之乘以一个负数可能会变成正数。因此，维护 `maxProd` 和 `minProd` 并在遇到负数时交换它们是一个有效的策略。

## 3. 前缀和与差值计算
   - **关键点**：在求和问题中，前缀和是一个强有力的工具。通过计算从数组开头到当前位置的前缀和，我们可以快速计算任意子数组的和。
   - **举例**：在和为 K 的子数组（LeetCode 560）中，我们使用前缀和的技巧来快速找到某个子数组的和是否为 `k`。通过记录前缀和并计算差值，可以快速找到目标子数组。

## 4. 环形数组处理
   - **关键点**：当数组可以看作是环形时，问题往往需要分两部分考虑：一是数组不跨越边界的情况，二是跨越数组边界的情况。
   - **举例**：在环形子数组的最大和（LeetCode 918）中，我们需要分别计算不跨越边界的最大子数组和，以及通过 `总和 - 最小子数组和` 计算跨越边界的子数组和。

## 5. 处理边界与特例
   - **关键点**：在处理动态规划的过程中，别忘了考虑边界情况，比如数组长度为 1 或出现 0 的情况。正确初始化状态也是非常重要的。
   - **举例**：对于最大子数组和问题，我们可以将初始值设为 `nums[0]`，而不是 `0`，这样可以正确处理只有一个负数的情况。

## 6. 利用哈希表优化
   - **关键点**：在需要快速查找和统计子数组的题目中，哈希表可以帮助我们高效地查找之前的状态。
   - **举例**：在 LeetCode 560 和 LeetCode 974 中，哈希表被用来记录前缀和的出现次数，帮助我们快速计算和满足条件的子数组个数。

## 7. 状态压缩
   - **关键点**：在一些问题中，我们不需要维护一个完整的动态规划数组，使用有限的变量即可完成状态更新，这样可以优化空间复杂度。
   - **举例**：在最大子数组和问题中，我们只需要两个变量来记录当前子数组和与全局最大和，避免使用额外的数组。

## 总结
解决“连续子数组”类问题的核心要点可以归纳为以下几点：
1. **动态更新状态**：维护当前最大/最小值、前缀和等，并根据当前元素实时更新。
2. **处理正负数影响**：尤其在涉及乘积时，负数会翻转结果，需要特别处理。
3. **前缀和与哈希表**：通过前缀和和哈希表的结合，快速解决和相关问题。
4. **环形数组与边界问题**：处理环形问题时考虑跨越边界的情况，并注意数组长度为 1 等边界条件。
5. **状态压缩**：尽量减少空间复杂度，使用常数级别的额外空间维护状态。

掌握这些要点，有助于快速识别问题的关键并选择合适的动态规划策略。
