#pragma once
#include <iostream>
#include <vector>
using namespace std;

/*
1246. 删除回文子数组
给你一个整数数组 arr，每一次操作你都可以选择并删除它的一个 回文 子数组 arr[i], arr[i+1], ..., arr[j]（ i <= j）。
注意，每当你删除掉一个子数组，右侧元素都会自行向前移动填补空位。
请你计算并返回从数组中删除所有数字所需的最少操作次数。
*/

/*
思路分析：区间DP
填充的顺序是区间长度递增的顺序！首先填充长度为1的区间，然后是长度2，然后是长度3，然后是长度4 ......

分成3中情况讨论：
    1）长度为1的区间，必然是回文，代价是1；
    2）长度为2的区间，取决于是否是回文，代价是1或者2；
    3）长度为3的区间，暴搜所有的2区间划分方法；若首尾字符相同，左右边界各内收一步，作为备选方法，并不一定优于2区间划分方法；
*/
class Solution {
public:
    int minimumMoves(vector<int>& arr)
    {
        int n = arr.size();
        // dp[i][j]表示删除区间子串[i:j]的最小步数；i/j是合法下标，很显然j>=i；
        int dp[100][100];

        // 长度为1的区间必然是回文，代价是1
        for (int i = 0; i < n; ++i) {
            dp[i][i] = 1;
        }

        // 长度为2的区间取决于是否回文，代价是1或2
        for (int i = 0; i < n - 1; ++i) {
            dp[i][i + 1] = (arr[i] == arr[i + 1]) ? 1 : 2;
        }

        // 暴搜所有长度>=3的区间
        // 以区间长度3为例，分成2个长度分别为1、2的区间讨论；而长度为1、2的区间，之前已经填充过了；
        // 以此类推，形成递推公式；
        for (int len = 3; len <= n; ++len) {
            for (int i = 0, j = len + i - 1; j < n; ++i, ++j) { // 长度为len的窗口滑动
                dp[i][j] = len; // 初始为最坏的情况：分别删除每个字符
                // 分成2个区间：[i, k]，[k+1, j]；暴搜所有的2区间划分方法
                for (int k = i; k < j; ++k) {
                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j]);
                }
                if (arr[i] == arr[j]) { // 首尾字符相同，区间内收；只能作为备选，并不一定优于2区间划分方法
                    dp[i][j] = min(dp[i][j], dp[i + 1][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
};