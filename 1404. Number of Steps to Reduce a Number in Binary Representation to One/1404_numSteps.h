#pragma once
#include <string>
using namespace std;

/*
算法类型：数组从后往前遍历。
需求分析：从二进制角度看，偶数除以2，相当于直接舍弃末尾的0；奇数+1，相对于把末尾连续的1翻转，并把连续1左边的第一个0置为1（进位）。

思路：分成2大块，分别处理连续的0，拿掉即可，每个0需要一个步骤；连续的1，也是拿掉即可，但是需要考虑进位。
难点：偶数除以2很好处理，难点在于奇数加1。末尾连续的1在加1之后，会翻转成连续的0。所以把它们当成连续的0拿掉即可。但是要记得把连续1左边的第一个0置为1（进位）。
     加1需要一个步骤；把n个连续的1（实际上，加1之后连续的1翻转成连续的0）当成连续的0处理，需要n个步骤；

*/
class Solution_1404 {
public:
    int numSteps(string s)
    {
        int idx = s.size() - 1;
        int ans = 0;
        while (idx > 0) { //第一位最后肯定剩1，此时已经结束，不再需要步骤。
            if (s[idx] == '0') { // 利用外层循环，即可处理连续的0.
                ans++;
                idx--; // 指针左移
            } else {
                ans++; //进位的步骤
                while (idx >= 0 && s[idx] == '1') { //进位后，连续的1会被翻转层连续的0，逐一拿掉即可。
                    ans++;
                    idx--;
                }
                if (idx > 0) // 此时idx要么溢出（-1，任务结束），要么指向连续1左边的第一个0，需要进位。
                    s[idx] = '1';
            }
        }
        return ans;
    }
};
