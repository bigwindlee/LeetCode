这道题涉及的核心知识点主要包括以下几方面：

### 1. **生产者-消费者模型**：
   - 生产者-消费者模型是多线程编程中的经典问题，生产者负责生产数据（`enqueue`），消费者负责消费数据（`dequeue`）。如果生产者生成的数据过快，消费者需要等待；如果消费者消费得过快，生产者也需要等待。
   - 该题目要求设计一个**有限阻塞队列**，即在队列满时阻塞生产者，在队列空时阻塞消费者。

### 2. **多线程同步**：
   - 生产者和消费者需要对队列进行并发访问，因此必须确保对队列的操作是线程安全的。通过**互斥锁（`mutex`）** 来保护对共享资源（即队列）的访问，避免线程竞争。
   - `std::unique_lock<std::mutex>` 用于对队列加锁，确保线程在操作共享数据时不会被其他线程干扰。

### 3. **条件变量（`condition_variable`）**：
   - 条件变量用于线程间的协调和通信。生产者线程在队列满时等待，消费者线程在队列空时等待。通过**条件变量**的 `wait()` 方法，使得线程可以在条件不满足时进入等待状态，而不会浪费 CPU 资源。
   - **`not_full`**：生产者在队列满时等待，直到队列不满时继续。
   - **`not_empty`**：消费者在队列空时等待，直到队列不空时继续。

### 4. **线程阻塞与唤醒**：
   - 当队列达到容量上限时，生产者线程会被阻塞，直到消费者消费数据并释放空间，唤醒生产者。
   - 当队列为空时，消费者线程会被阻塞，直到生产者添加新数据，唤醒消费者。

### 5. **互斥锁与条件变量配合**：
   - 使用**互斥锁**来保护共享队列的操作，并配合**条件变量**来阻塞和唤醒线程。`unique_lock` 和 `condition_variable` 是多线程编程中常用的同步机制，能够有效控制线程之间的执行顺序和协调。

### 总结：
- **生产者-消费者模型**：经典的多线程问题，通过阻塞和唤醒线程来协调生产者和消费者。
- **线程同步与互斥锁**：通过 `mutex` 保证对共享资源的访问是线程安全的。
- **条件变量**：用来让线程在等待某个条件时进入阻塞状态，条件满足时再唤醒，从而避免忙等待问题。
- **队列的容量控制**：通过条件变量来实现对队列的容量控制，生产者在队列满时阻塞，消费者在队列空时阻塞。
