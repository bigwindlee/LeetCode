#pragma once
#include <string>
#include <vector>
using namespace std;

/*
1041. 困于环中的机器人
在无限的平面上，机器人最初位于 (0, 0) 处，面朝北方。注意:
  - 北方向 是y轴的正方向。
  - 南方向 是y轴的负方向。
  - 东方向 是x轴的正方向。
  - 西方向 是x轴的负方向。

机器人可以接受下列三条指令之一：
  - "G"：直走 1 个单位
  - "L"：左转 90 度
  - "R"：右转 90 度
机器人按顺序执行指令 instructions，并一直重复它们。
只有在平面中存在环使得机器人永远无法离开时，返回 true。否则，返回 false。

思路分析：（数字化方向和行走）
东南西北4个方向分别用数字0/1/2/3表示。方向和数组下标刚好对应，这样就可以用二维数组表示每个方向走一步的坐标变化！
那么当方向分别是东南西北时，G指令导致的坐标变化：
{ 1, 0 }, { 0, -1 }, { -1, 0 }, { 0, 1 }  // 东走一步，x坐标+1；南走一步，y坐标-1；以此类推...
任意方向，右转+1，左转-1；考虑到溢出，对4取余数；

难点：
  - 要理解最多4轮回到原点。超过4轮就永远回不到原点了。
  - 不用走完4轮，只要走一轮，方向发生了变化，也能回到原点。
*/
class Solution {
public:
    bool isRobotBounded(string instructions)
    {
        int ori = 3, x = 0, y = 0; // 初始方向和坐标
        vector<vector<int>> go { { 1, 0 }, { 0, -1 }, { -1, 0 }, { 0, 1 } }; // 方向分别是0/1/2/3时，G指令导致的坐标变化。

        for (char c : instructions) {
            if (c == 'L') {
                ori = (ori + 3) % 4; // 左转方向变化
            } else if (c == 'R') {
                ori = (ori + 1) % 4; // 右转方向变化
            } else {
                x += go[ori][0];
                y += go[ori][1];
            }
        }
        // 回到了原点，或者没回到原点，但方向发生了变化，那么经过2轮或4轮指令，也能回到原点。
        return ori != 3 || (x == 0 && y == 0);
    }
};