思路：
  1）Method0是一个暴力穷举的解法；使用InOrder遍历树（BST在InOrder遍历下是升序的），每走到一个节点，从之前收集到的有序数组中搜索 (k-root.Val) 值。因为是有序数组，因此使用折半查找。

  2）Method1的解法更高效，因为基于这样一个事实：从一个有序数组中找2个数，使之和为 k；从数组的首尾两端夹逼即可[ i, j := 0, len(nums)-1  然后 i++ 或者 j-- ]，每次执行 i++ 或 j-- 都是唯一正确的方向。

  有了前述的前提，高效的解法是使用 InOrder 把节点值全部收集到一个升序数组中，然后在这个数组中找2个数的和，使之等于k。
