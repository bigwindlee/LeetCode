#pragma once
#include <map>
#include <unordered_map>
#include <vector>
using namespace std;

/*
3009. 折线图上的最大交点数量
有一条由 n 个点连接而成的折线图。给定一个 下标从 1 开始 的整数数组 y，第 k 个点的坐标是 (k, y[k])。图中没有水平线，即没有两个相邻的点有相同的 y 坐标。
假设在图中任意画一条无限长的水平线。请返回这条水平线。

思路分析：
每一根折线在y轴上的投影，其2端必然是整数点；而水平线在在y轴上的投影是一个点。

难点1：
水平线要和折线段取得最多的交点，有2种情况：
    1）水平线的y坐标在2个整数点之间，为方便计算，取2个整数中间的位置，也就是1.5, 2.5, 3.5, ...这种；
    2）水平线的y坐标为整数点位。

难点2：
水平线的y坐标是动态变化的，看起来可以取0.5的步长；但是考虑到编程实现，把所有折线段的y坐标放大2倍，那么水平线的y坐标步长就可以放大到1，这一点对编程实现很重要！

难点3：
这个问题映射到什么样的数据结构最合适？差分数组！
我们可以在每个折线段的y坐标范围(y1, y2)内，以步长为1（实际步长是0.5）统计水平线在这个位置能产生的交点数。
我们在以步长为1统计每根水平线生成的交点数的时候，如果y1, y2之间的距离非常大，我们假设中的水平线也会非常的多，这会导致非常大的计算量和存储空间！
因为每多出一根折线，我们要为(y1, y2)之间的每一个整数点对应的交点个数增大1。这不就是区间的频繁更新操作吗？正符合差分数组的使用场景！
我们不必真正的统计(y1, y2)之间的每个整数点，采用差分数组的话，每多出一根折线(y1, y2)，我们只需要对diff[y1]增大1，diff[y2+1]减少1；
差分数组用map实现，因为要保证key的顺序。（这么一想，map似乎是数组的某种特化，因为我们只需要存储某几个关键的key对应的值。）

难点4：
考虑2根相邻的折线，左边折线的终点恰好是右边折线的起点。为了避免重复的统计，我们在统计每根折线造成的交点个数变化时，忽略掉折线的终点。也就是最后一根折线的终点要单独计算。


知识点：
1）`map`与`unordered_map`的区别，及使用场景：
map：基于红黑树实现，键值对按照键的顺序存储。因此，map是有序的。迭代时，元素按照键的顺序排列。
unordered_map：基于哈希表实现，键值对没有特定的顺序。因此，unordered_map是无序的。

2）差分数组
对于一个长度为 n 的原始数组 A，差分数组 D 定义如下：
    D[0] = A[0]
    D[i] = A[i] - A[i-1] (对于 1 ≤ i < n)
差分数组的元素 D[i] 表示原始数组 A 中相邻元素的差值，换句话说，差分数组表示了原始数组在每个位置的变化量。

3）c++中遍历哈希表（结构化绑定）
    for (const auto& [k, v] : my_map)
    map按照key的升序进行遍历；unordered_map的遍历顺序不可预测；

*/

class Solution_3009 {
public:
    int maxIntersectionCount(vector<int>& y)
    {
        int n = y.size();

        //重要技巧：把所有折线段的y坐标放大2倍，那么水平线的y坐标步长就可以放大到1；
        for (int i = 0; i < n; i++) {
            y[i] *= 2;
        }

        map<int, int> diff; // 差分数组：diff[a] = b 表示y坐标为a的水平线和折线所产生的交点个数为b
        for (int i = 1; i < n; i++) {
            int l = min(y[i], y[i - 1]), r = max(y[i], y[i - 1]);

            // 每一条折线对差分数组的影响：
            diff[l]++;
            diff[r + 1]--;

            // 为避免重复统计，忽略掉每根折线的终点造成的影响；
            diff[y[i]]--;
            diff[y[i] + 1]++;
        }

        // 最后一根折线的终点造成的影响，单独计算；
        diff[y[n - 1]]++;
        diff[y[n - 1] + 1]--;

        // 差分数组实际上存储的是相邻2个元素的增量，遍历并累加增量，实际上就是恢复了每个元素的值；从这些恢复的值里面去寻找最大值；
        int s = 0, ans = 0;
        for (const auto& [_, v] : diff) { // 按照key的升序进行遍历，这是map的特点。
            s += v;
            ans = max(ans, s);
        }
        return ans;
    }
};
