#pragma once

/*
7. 整数反转
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。
如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
假设环境不允许存储 64 位整数（有符号或无符号）。

思路分析：
难点1：余数的定义。2个正整数的余数很好说，如果被除数/除数引入负数呢？
基本的原则是：商尽量靠近0；再加上余数的时候，是远离0点的方向往外走；
这样就保证了余数的符号和分子（被除数）相同；因为分母（除数）和商的和要加上余数才能到达分子！
具体到本题，while循环就不需要单独的处理x为负数的情况，达到了统一！这是因为如果x为负数，则x%10和x/10都是负数！

难点2：怎样判断ans溢出？题目要求反转后的整数如果超出32位有符号整数的范围，就返回0.
如果每次都要和INT_MAX/INT_MIN比较，显得丑陋，性能也低。
技巧在于，用long容纳ans，最后在将ans强制转换为int，如果强转后和原ans在数值上相等，就表示强转没有丢失比特，也就是没有溢出！
如果不允许使用long，就只能这样判断：if (ans < INT_MIN / 10 || ans > INT_MAX / 10)

*/

class Solution_0007 {
public:
    int reverse(int x)
    {
        int ans = 0;
        while (x != 0) {
            // 数学上可以证明，这样的判断是足够的。
            if (ans < INT_MIN / 10 || ans > INT_MAX / 10) {
                return 0;
            }
            ans *= 10;
            ans += x % 10;
            x /= 10; // 循环迭代
        }
        return ans;
    }
};

class Solution_0007_bak {
public:
    int reverse(int x)
    {
        long n = 0;
        while (x != 0) {
            n *= 10;
            n += x % 10;
            x /= 10;
        }
        // 如果题目允许使用long，则可以使用long强转int看比特是否丢失的技巧。
        return (int)n == n ? (int)n : 0;
    }
};